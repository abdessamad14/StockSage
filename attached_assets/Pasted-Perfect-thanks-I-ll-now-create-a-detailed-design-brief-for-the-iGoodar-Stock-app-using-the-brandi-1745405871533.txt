Perfect, thanks! I’ll now create a detailed design brief for the iGoodar Stock app, using the branding from your Canva link, and ensuring everything is tailored for mobile-first use, offline support, drawer navigation, manual language switching, and both modes of barcode scanning. I’ll include technical architecture, feature breakdowns, and UI notes to guide your development team on Replit. I’ll let you know as soon as it’s ready!

# iGoodar Stock – Mobile App Design Brief

## Project Overview  
iGoodar Stock is a **mobile-first SaaS application** for Moroccan very small businesses (VSBs) – such as wholesalers, mini-markets, and small retailers – to manage their stock and sales operations. The app’s primary goal is to **simplify inventory management, POS sales, B2B ordering, and credit tracking** in an offline-capable system. It will empower users with low technical literacy to handle daily business transactions (selling, purchasing, stock adjustments, etc.) entirely on a mobile device, even with unreliable internet. By combining an intuitive interface with robust offline-first technology, iGoodar Stock aims to replace manual ledgers and Excel files with a modern, efficient solution tailored to local needs (French/Arabic language support, Dirham currency, thermal receipt printing, etc.).

## Branding & Visual Identity  
All UI design will follow the **iGoodar Stock brand guidelines** provided (via the Canva brand kit link). This means using the official color palette, logo, and typography to ensure a consistent identity. Key considerations include:  

- **Color Scheme & Logo**: Apply the primary brand colors for headers, buttons, and highlights (e.g. accent colors for action buttons or selection states) and secondary colors for backgrounds and less prominent elements. The logo should appear on the login screen, drawer header, and printed receipts/PDFs. Overall, the look should feel modern yet friendly, aligning with the brand’s style.  
- **Clean, Simple Aesthetics**: Use a **clean layout with plenty of white space** and high-contrast text for readability. Icons should be simple and recognizable (e.g. a barcode icon for products, a cart for POS, a truck for suppliers). The design will avoid clutter – each screen focuses on one primary task to prevent overwhelming the user.  
- **Mobile-First Typography**: Use legible fonts from the brand kit (or platform defaults if none specified) at sizes that are easily readable on 5–7 inch screens. Important labels (like product names, totals) should be slightly larger or bolder. Support both Latin and Arabic script fonts, ensuring Arabic text uses an appropriate font for clarity.  
- **Low-Tech Friendly UI**: The interface should **prioritize clarity over complexity**. For example, use labels and icons together for menu options (bilingual if possible) so that even users with limited reading ability can navigate. Interactive elements (buttons, links) will be clearly distinguished with brand colors and not hidden behind gestures.  

## Technology Stack & Architecture  
The application is built with a **robust, offline-first architecture**. Below is an overview of the chosen tech stack and how each component fits into the system design:

- **Frontend Platform – React Native (Expo)**: The mobile app is developed in React Native using Expo for rapid development and deployment. Expo provides native capabilities like camera access, file system, and a built-in SQLite database. Using Expo’s managed workflow keeps the app lightweight and enables easy publishing to both iOS and Android from a single codebase. Notably, **Expo includes an SQLite database for persistent local storage** ([react native - Offline database in Expo - Stack Overflow](https://stackoverflow.com/questions/54590679/offline-database-in-expo#:~:text=As%20mentioned%20by%20Bruno%20Eduardo,You%20import%20SQLite%20from%20expo)), which we leverage for offline data. We will use the latest React Native techniques for performance (e.g. Hermes engine for smaller bundle and faster startup). The target is to keep the app size under **20 MB** for quick downloads and to accommodate devices with limited storage.  

- **Offline Data Storage – SQLite + MMKV**: **100% Offline-first** is a core requirement. The app will use **Expo’s SQLite** database to store all business data locally (products, inventory, sales, etc.), and **MMKV (a fast key-value storage)** for caching small pieces of state or configuration. This combination allows the app to function without internet: users can create invoices, lookup stock, etc., entirely offline. All write operations (sales, orders, updates) will be applied to the local SQLite DB immediately. **When a network connection is available in the background, the app will sync with the cloud server**, pushing local changes and pulling any updates from other devices/users. This ensures that even if a shopkeeper works offline all day, no data is lost – it’s synced once they reconnect. As a reference, Sortly (a similar inventory app) follows this approach: *when offline, it saves your changes so you can still view and edit inventory, and when you come back online it automatically syncs updates across all devices* ([Offline Inventory Management | Sortly](https://www.sortly.com/features/offline-inventory-management/#:~:text=)). We will implement a similar **background sync service** that listens for connectivity changes and performs synchronization silently. Any conflicts (e.g. the same item updated on two devices) will be resolved on the server using timestamps or last-write-wins logic.  

- **Backend – Node.js or Spring Boot REST API**: The backend server will expose **RESTful APIs** for all functionalities (auth, CRUD operations, sync). It will be designed as a **multi-tenant** system: each business (tenant) has isolated data. We have flexibility in technology: either a **Node.js** server (using Express or NestJS) or a **Java Spring Boot** application can fulfill the requirements. In either case, the API will enforce business separation, handle authentication, and coordinate data sync. Key considerations:  
  - **Multi-Tenant Data Isolation**: The backend uses **PostgreSQL with a schema-per-tenant model**. On user signup, a new schema is created for that business, containing all necessary tables (products, sales, etc.) for that tenant. This approach ensures **each customer’s data is in a separate schema and never intermingles with other customers’ data** ([Designing Your Postgres Database for Multi-tenancy | Crunchy Data Blog](https://www.crunchydata.com/blog/designing-your-postgres-database-for-multi-tenancy#:~:text=If%20you%27re%20building%20a%20B2B,offs%2C%20and%20scaling%20opportunities)) ([Designing Your Postgres Database for Multi-tenancy | Crunchy Data Blog](https://www.crunchydata.com/blog/designing-your-postgres-database-for-multi-tenancy#:~:text=,are%20fully%20isolated%20in%20schemas)). In other words, *customers are fully isolated in schemas* ([Designing Your Postgres Database for Multi-tenancy | Crunchy Data Blog](https://www.crunchydata.com/blog/designing-your-postgres-database-for-multi-tenancy#:~:text=,are%20fully%20isolated%20in%20schemas)). This gives strong data privacy guarantees while still using a single database instance. (We acknowledge the trade-off that migrations need to be applied to each schema ([Designing Your Postgres Database for Multi-tenancy | Crunchy Data Blog](https://www.crunchydata.com/blog/designing-your-postgres-database-for-multi-tenancy#:~:text=Pros%3A)), but for a SaaS targeting VSBs, the scale is manageable and the benefits of isolation are paramount.) The server will determine which schema to use based on the authenticated user’s tenant ID (for example, by setting the PostgreSQL `search_path` on each request or maintaining separate DB connections per tenant).  
  - **REST API Design**: All core entities (users, articles, stores, sales, orders, etc.) will have REST endpoints (e.g. `POST /api/:tenantId/articles`, `GET /api/:tenantId/sales`) or a proxy that infers tenant from the JWT. The API will be stateless and adhere to REST principles, making it easy to integrate with the mobile app’s data sync routines. We’ll implement **pagination** on list endpoints for efficiency and **batch endpoints** for syncing (e.g. sending multiple records in one request to reduce round trips).  
  - **Choice of Framework**: If using **Node.js**, we may use an ORM like Sequelize or TypeORM which supports schema-based multitenancy, or run raw SQL queries with schema qualification. If using **Spring Boot**, we can leverage Spring Security for JWT authentication and Hibernate with multi-tenant configurations (database-per-tenant or schema-per-tenant strategy). The multi-schema approach in Postgres is well-supported by frameworks (for example, setting the Hibernate property to use a schema discriminator or using separate DataSources).  

- **Authentication & Security**: Authentication is **JWT-based**. Users will log in with an email or phone number plus password (or OTP in future), and upon successful login, the app receives a JWT. This token encodes the **tenant ID** (to identify the business) and the user’s **role**. Storing roles in the JWT is intentional – it makes it easy to enforce role-based access in both the frontend and backend without extra DB lookups ([Easy way to put user role in JWT | Cerbos](https://www.cerbos.dev/blog/easy-way-to-put-user-role-in-jwt#:~:text=Including%20user%20roles%20directly%20in,streamline%20authentication%20and%20authorization%20processes)). In other words, *including user roles directly in the JWT makes it easier to implement role-based access control (RBAC) without constantly querying the database* ([Easy way to put user role in JWT | Cerbos](https://www.cerbos.dev/blog/easy-way-to-put-user-role-in-jwt#:~:text=Including%20user%20roles%20directly%20in,streamline%20authentication%20and%20authorization%20processes)). The JWT will be used on every API call (as an `Authorization: Bearer` header), and the backend will verify it and extract the claims. We will use strong JWT signing keys and proper expiry (e.g. 24-hour tokens with refresh logic) to keep the system secure. Passwords will be hashed (if using our own auth) or we may integrate with a third-party SMS/email OTP service for simplicity. Role-based authorization rules will be enforced on the server (e.g. only an Admin can create new users, only an Admin or maybe Supporter can adjust inventory, etc.). On the client, we’ll also hide or disable UI for unauthorized actions based on the user’s role, to improve UX.  

- **Roles & Permissions**: We plan for five roles: **Admin**, **Cashier**, **Merchant**, **Supporter**, and **Viewer**. These roles define the level of access:  
  - **Admin** – The business owner or manager. Full access to all modules: can add users, configure settings, view all reports, and perform all operations. Essentially the tenant “superuser”.  
  - **Cashier** – A point-of-sale staff role. Can create sales (POS module), lookup products, and manage customer credit during a sale. Cashiers might also create customer entries on the fly. They **cannot** alter high-level settings, manage inventory in bulk, or view certain sensitive data like cost prices or profit reports (unless allowed; this can be configurable). Their UI will be simplified to just the POS screen and perhaps basic product lookup.  
  - **Merchant** – This role is intended for B2B clients of a wholesaler. A user with Merchant role can **place orders** to the business but has no access to internal management. (In practice, a wholesaler could create accounts for their frequent buyers so they can send orders through the app). A Merchant logs in and sees only the catalog of products and an order submission interface. They cannot see other customers or any of the business’s financial info.  
  - **Supporter** – A support or auditor role. This could be used by an external accountant or a technical support agent. They may get **read-only or limited write access** to assist the business. For example, a Supporter might view settings and data to help troubleshoot, or generate reports, but not record transactions. (Exact permissions can be refined – for now assume Supporter is read-only on all data, or read/write on non-critical data, as per business needs.)  
  - **Viewer** – A strictly **read-only** role. They can view all data and reports but cannot make any changes. This might be given to an owner’s business partner or an accountant who needs to monitor records without editing.  

  The app’s navigation will adapt based on role (e.g. a Cashier won’t see the User Management or Settings sections in the menu). The backend will double-check permissions on each request to ensure, for instance, a Cashier token cannot call an admin-only API. This layered security ensures both **usability** (each user only sees what they need) and **safety**.

- **Printing Support**: iGoodar Stock supports **thermal receipt printers (ESC/POS)** as well as standard A4 printers for invoices/reports. On the mobile app, we will integrate a React Native module for Bluetooth/USB thermal printers (ESC/POS protocol). This allows printing small receipts (e.g. sales receipts, order confirmations) on 58mm/80mm paper rolls directly from the phone. There are open-source libraries (for example, the `react-native-bluetooth-escpos-printer` module) that enable sending text and simple graphics to a paired Bluetooth printer. We will likely include such a library and provide a UI in the app’s Settings to **pair and test the printer**. (Expo’s managed workflow may require using a development build or EAS to include this native module, which we will account for in deployment.) Additionally, for full-page printing needs (like end-of-day reports or detailed invoices), the app can generate a PDF and use Expo’s Print API or share functionality. Expo’s `Print.printToFileAsync` will help create PDF documents; the user can then print that PDF via AirPrint or a connected printer. Essentially, **thermal printers for receipts** will be used in the POS module, while **PDF generation** is used for larger reports (which can then be printed on A4 or shared via email/WhatsApp).  

- **Barcode Scanning**: The app will support two scanning modes:
  1. **External Bluetooth Scanner**: Many shop owners use handheld Bluetooth barcode scanners that act as keyboard input devices (HID). The POS interface will be designed to accommodate this – for example, having a hidden text input that automatically captures scanner input. When the user scans a barcode with the external scanner, the code will appear in the input and trigger a search/add action (as if the user typed the barcode and pressed enter). This “auto-trigger” scanner support requires that the app listens for scanner input events even if a text field isn’t manually focused, which we will manage by focusing a dedicated barcode field whenever the POS screen is active. 
  2. **Camera Scanning**: For users without a dedicated scanner, the app will provide a **built-in camera scanner**. Using Expo’s Camera and BarCodeScanner modules, the app can open a camera view (with an on-screen target reticle) to scan barcodes or QR codes. This can be used in the POS (to add items by scanning) or in the product management (to quickly fill in a new product’s barcode). We will optimize the scanner for common barcode types in retail (EAN-13, Code128, QR, etc.). Scanning feedback (beep or vibration) will be given upon success. In offline mode, all product barcodes are stored locally so the lookup is instant.  

- **App Navigation & Layout**: The app uses a **side drawer navigation** pattern to accommodate many modules in a simple way. On small screens (5–7 inches), a bottom tab bar might not fit all sections comfortably, so a hamburger menu is ideal. We’ll implement a slide-out **Drawer Menu** (using React Navigation’s DrawerNavigator) that lists the main sections: Dashboard, POS, Articles, Inventory, Customers, Suppliers, Orders, Reports, Settings, etc. The drawer will be accessible via a menu icon on the top-left (or top-right for RTL Arabic UI) of the header. Each of the modules has its own screen or stack of screens, accessible from this menu. The drawer menu will show the business name/logo at the top (reinforcing brand identity) and possibly the logged-in user’s name and role. We will limit the primary menu items to around 7 or 8 for clarity (some less-used features might be nested within Settings or so). The navigation will also account for **RTL layout** – when the app is in Arabic, the drawer should slide out from the right side and the arrow icons should flip direction. React Native’s support for RTL will make this possible with the appropriate settings (leveraging `I18nManager` to flip layouts at runtime).  

- **Localization (Arabic & French)**: The app will be bilingual, supporting **French** and **Arabic** (with Arabic in **RTL**). Instead of relying solely on device language (since many Moroccan devices might be set to French even if the user prefers Arabic or vice-versa), we will include a **manual language switcher** in the app (likely in the Settings module, possibly also on the login screen). This allows the user to toggle the interface language anytime. All text in the app (labels, messages, errors, etc.) will be externalized into translation files for easy maintenance. We’ll use an i18n library (like i18next or react-intl) along with Expo’s localization utilities. When Arabic is selected, we will activate RTL layout for the entire app. **React Native natively supports RTL** layout mirroring ([Implementing Right-to-Left (RTL) Support in Expo Without Restarting the App - GeekyAnts](https://geekyants.com/en-us/blog/implementing-right-to-left-rtl-support-in-expo-without-restarting-the-app#:~:text=Step%203,Your%20Project)) – by using `I18nManager.allowRTL(true)` and `I18nManager.forceRTL(true)` as needed, the UI will flip horizontally to suit right-to-left reading. We will ensure that our styles use logical properties (`Start`/`End` instead of explicit Left/Right) so that most UI components automatically adjust to RTL. Text will be translated carefully by a fluent speaker to ensure accuracy and cultural relevance. The two languages can be updated independently, and we’ll store the user’s language preference (in MMKV or backend) so it persists.  

- **Database – PostgreSQL (Multi-Schema)**: As mentioned, the database is PostgreSQL, chosen for its reliability and support for JSON and complex queries if needed. Each tenant gets a separate schema in the same database. All schemas share the same structure (tables for users, products, sales, etc.), but contain only that tenant’s data. This design facilitates simpler backups (you can backup per schema if needed) and improves security (accidentally querying across tenants is prevented by design). We will maintain a **master schema** (or the public schema) to hold global data and metadata: e.g., a master “tenants” table listing all businesses, perhaps a table of supported languages or static reference data. User accounts might exist in a global auth table if we allow one user to access multiple tenants, but in this case, likely each user is tied to one business. We will also implement **DB migration tools** to propagate schema changes – for Node, a tool like Prisma or Liquibase (for Java) can update all schemas with new columns or tables when the app upgrades.  

- **Networking & Sync**: The app will use a background task or event-driven approach for sync. We’ll utilize **Expo’s NetInfo** to detect connectivity changes. When the app goes from offline to online, or at periodic intervals (e.g. every 15 minutes), it will attempt to sync: send any new/updated records from SQLite to the server (through batch API calls), and fetch any new data from the server (updates done by other users or devices). The sync process will be optimized to send minimal data (e.g. using timestamps or change tracking to only send delta). We might implement a queue system for actions performed offline – for example, each new sale or order is queued in an “outbox” table, and on sync the outbox is processed and cleared. This ensures durability (even if the app crashes before syncing, the outbox keeps the pending operations). The server, upon receiving synced data, will apply it to the Postgres DB and respond with success or conflicts. In case of conflict (e.g., two users edited the same product’s price), the server could include both versions or an error; for simplicity, we may decide that the last synced update wins, and perhaps log the conflict for admin review. The user will be informed of sync status – e.g. a small indicator in the app header or a pull-to-sync in each list. In essence, when connectivity is restored, the goal is that the local database and server become eventually consistent without user intervention.  

- **Performance & Size Optimizations**: Given the target users may have budget Android devices, performance is key. We will enable **Hermes (JS engine)** to reduce app size and improve launch speed. We’ll also employ code-splitting and lazy loading of modules – e.g., the Merchant order module or certain heavy reports might only load when needed. The target is **<20 MB APK** and similarly lean iOS size. Images used in the app (icons, etc.) will be optimized or vectorized. Database indices will be set on frequently searched fields (like barcode, product name) to keep lookups fast even as data grows. We expect the amount of data per tenant to be moderate (perhaps hundreds or a few thousand products, and transaction logs in the low tens of thousands), which SQLite can handle easily on device. We will periodically purge or archive old data if needed (for example, sales older than X years could be archived to reduce local DB size, while remaining available via the server if needed). The offline-first approach also means the app should **never freeze** waiting for a network call – all interactions are instantaneous with local data, and sync happens in the background thread. We will take care to **prevent UI blocking** on any heavy operations: for instance, bulk imports or massive queries will be done with progress indicators or in chunks to keep the UI responsive.  

With the stack and architecture in place, the following sections detail each module/feature of the app and how it will be designed and implemented.

## Feature Modules and Implementation Details  

### Authentication & Multi-Tenancy  
**Features:** New users can sign up with an email or phone number and password. Existing users can log in using their credentials. The first user to sign up for a business effectively creates a **tenant account** (business account). This will trigger creation of that business’s data schema on the backend. Users invited to an existing business simply log in after being added by an Admin. Basic account management (password reset, etc.) is included. The app should remember logged-in sessions (so users don’t have to log in each time, especially if offline). 

**Implementation:** Upon signup, the app collects business details (e.g. Business name, owner name, contact) and user credentials. A request is sent to `POST /api/auth/register` – the server will create a new tenant entry, set up a new schema (copying the template structure), and create the admin user in that schema. On success, it returns a JWT token. The mobile app stores this JWT securely (using **MMKV or Expo SecureStore**) for automatic login. Logging in (`/api/auth/login`) returns a JWT if credentials match an existing user. The JWT contains the `tenantId` and `role`. The app will decode it (to know which role to apply for UI purposes) and then include it in all future API calls.

For **offline login**, we will implement a fallback: after the first successful online login, the app has the user’s credentials/token cached. If the user opens the app offline, we can allow access based on the last saved credentials, showing a badge “Offline Mode”. They can use the app fully offline and any changes will sync later. (We might restrict certain operations if never logged in before on that device, to avoid an unverified user creating a new account offline that the server doesn’t know about.)

Multi-tenancy on the client side means the app needs to know which business it is operating in – since one app instance is essentially tied to one tenant (we are not supporting one user managing multiple businesses in the same app session at this time). So after login, all data in SQLite is specific to that tenant. If in the future we allowed switching tenants, we’d need separate SQLite databases per tenant to keep data separate. 

The JWT-based auth is stateless. The backend will decode JWT, extract tenantId and role for each request, then **set the search_path to that tenant’s schema** in Postgres for the duration of the transaction (or use separate connections per schema). Thus every query runs in the context of the correct tenant schema. This ensures **isolation by default**, as noted earlier. (Alternatively, the APIs could be prefixed with tenant, but we prefer using the token to avoid accidental cross-tenant queries.) 

We will implement **role-based authorization** checks in endpoints. For example, the `/api/users/invite` endpoint (to add a new user) will verify that the JWT’s role is Admin before proceeding. Similarly, certain endpoints like `/api/inventory/adjust` might allow Admin and Supporter, but not Cashier. These rules will mirror on the frontend by hiding/showing features. 

Security measures include using HTTPS for all API calls (especially important once the app syncs data when online), storing tokens securely, and possibly implementing refresh tokens if session longevity is an issue. For the MVP, a long-lived JWT that can be revoked via backend (in case of misuse) might suffice.

### User Management (Admin)  
**Features:** Allows an Admin to manage the users in their business (tenant). The admin can invite new users (e.g. add a cashier or another admin), edit user roles, or remove users. This module ensures proper access control within the tenant. It might also show a list of active sessions or last login times for security monitoring. 

**UI/UX:** This will likely be a screen under Settings or a dedicated “Users” section accessible to Admins only. It will list existing users (name, email/phone, role). Admin can tap “Add User” which opens a form to input the new user’s email/phone and assign a role. The invite could be processed simply by creating the user in the system (with a temporary password or activation link). Since the app is offline-first, inviting a user while offline should be queued and sent when back online – though practically adding a user will require network to communicate the invite (we could allow offline addition and send an SMS invite when online). For MVP, we might make user invitations an online-only action with a friendly message if offline (because the invited user can’t use the app until the server knows about them). 

**Implementation:** In the backend, a `users` table (in each tenant schema) stores user accounts for that business. When an Admin invites someone, the app calls `POST /api/users` with the new user’s info. The server creates the user (assigning them a role and linking to that tenant). If using email, the server might send an invite email with a link to set a password. If using phone, maybe send an SMS with a temporary code. These details can be handled via integration with an email/SMS service. For now, we can assume the Admin will set a password for the new user and communicate it. The new user then logs in normally. 

Editing a user (e.g. changing role or disabling an account) would be available for Admin. Removing a user might set a flag rather than hard-delete (to preserve transaction history integrity – we wouldn’t want to delete a user who recorded sales, but just prevent future login). This could be an “Archive” or “Deactivate” action.

On the frontend, after any changes, the local SQLite user list will be updated accordingly (so that, for example, the Admin sees the updated role list even offline). If a user’s own role was changed (like an Admin downgrading themselves, which is unlikely, or someone else becoming Admin), the app might prompt them to re-login or adjust available features immediately.

Proper **role management UI** will ensure an Admin cannot revoke their own admin rights (to avoid leaving the tenant without an admin) and possibly limit certain roles (e.g. you must have at least one Admin user active). 

This module is relatively small but critical for multi-user businesses (wholesaler might have multiple cashiers, etc.).

### Article Management (Products)  
**Features:** This module handles all **inventory items (articles)**. Users can create new product entries, edit details, and view their current stock. Key fields for each article include:  
- **Name:** the product name (e.g. “Coca-Cola 330ml Can”) – supports multiple languages if needed, but we might store just one name field (users might input in French or Arabic as they prefer).  
- **Barcode:** the unique barcode or SKU. Can be EAN/UPC or any identifier used in the store. This will be used for scanning and quick lookup.  
- **Image:** an optional photo of the item for visual identification (stored as a URI or base64 in the local DB, and synced to server storage).  
- **Purchase Price (Cost):** the price at which the business buys this item from suppliers (in MAD).  
- **Selling Price:** the retail price for selling to customers (for POS). Possibly support multiple price tiers in future, but for now one selling price.  
- **Quantity (Stock):** the current quantity on hand in the default unit (see below) across the store or per store (if multi-store, stock is tracked per store in a related table – more on that in Inventory module).  
- **Unit:** the unit of measure (e.g. “piece”, “kg”, “liter”). Many items will be counted in units, but for completeness, we allow specifying unit to display and manage inventory accordingly.  
- **Minimum Qty:** the threshold below which this item is considered “low stock”. When stock dips below this, an alert/notification is triggered so the owner knows to reorder.  
- **PMP:** *Prix Moyen Pondéré* (average weighted cost price). This is a calculated field representing the average cost of the item taking into account all purchase batches. It updates when new stock is purchased. For simplicity, the user may input an initial cost which acts as PMP until changed. The system can auto-calc PMP as `(old_stock * old_PMP + new_stock * new_purchase_price) / (old_stock + new_stock)` whenever a purchase is recorded. This helps calculate profit margins.  

In addition, we could track **category** (e.g. Beverage, Snack) but that wasn’t explicitly mentioned – it might be a nice-to-have for filtering but not core. We will focus on the given fields.

**UI/UX:** The Article Management screens include: 
- A **Product List** view – showing a scrollable list of all articles with key info (maybe name, stock qty, selling price, and a small thumbnail). A search bar at the top allows finding a product by name or scanning a barcode to jump directly to it. If the user scans a barcode from this screen (via camera or external scanner), the app will filter or highlight the matching item. 
- An **Add New Product** form – where the user enters all the fields above. The form should be simple: e.g., Name (text), Barcode (text or **scan button** to fill it), Purchase Price & Selling Price (numeric inputs, possibly with currency “MAD” label), Unit (pick from common units or free text), Minimum Qty (number). There will be an option to **capture a photo** (launch camera to take picture of the product or choose from gallery). The image, if taken, will be stored locally (and a sync task will later upload it to the server, possibly to an S3 bucket or supabase storage, storing the URL in the DB). 
- An **Edit Product** screen – similar to Add, but pre-filled with the existing data, and possibly showing additional info like current stock across stores. The user can update prices, etc. (We might restrict certain fields like current stock not editable here – stock changes through purchase or manual adjustments, not directly in the product form except maybe initial stock on creation). 
- Possibly a **Product Details** view – could be the same as edit, or a read-only view showing more stats (e.g. total sold in last month, etc. not in MVP). 

**Bulk Import:** A major feature is the ability to **bulk import products from an Excel file**. This helps new users onboard by importing their existing inventory list (like the provided `new.xlsx` template). The app will provide an option (maybe in the Product list screen or in Settings > Import Data) to select an Excel/CSV file. We’ll support a specific template format with columns such as *Reference*, *Article Name*, *Initial Stock Quantity*, *Unit*, *Purchase Price*, *Selling Price*, etc. (The example file shows columns in French/Arabic; we’ll supply a template in French for users to fill). When the user selects the file (using Expo’s DocumentPicker), the app (if online) could upload it to the server for processing, or (to allow offline use) the app could parse it locally using a JavaScript XLSX library. Given performance concerns on device, a simpler approach is to accept CSV format as well. We will likely implement: user downloads template, fills it, then in app chooses “Import”. The file is processed (either locally or by sending to an `/api/import` endpoint). Each row is then inserted into the SQLite database as a new product entry. The app will then sync those to the server like normal creates. We’ll handle duplicates (if a barcode in the file already exists in DB, we might update the info or skip, informing the user). After import, the user will see all their products listed. This feature will save time for businesses that already catalogued inventory in spreadsheets. 

**Stock Alerts:** The app will automatically watch product quantities against their **Min Qty**. Whenever stock is updated (after a sale or purchase), the app checks if `Quantity < MinQty`. If yes, that product is added to a **Low Stock list** and a local notification can be triggered: “⚠️ Low stock: [Product Name] only [Qty] left”. These alerts are important for wholesalers to know when to reorder. Even offline, this logic works since it’s based on local data. Additionally, on the Dashboard, we might display a count of low-stock items for quick attention. Users can adjust Min Qty per product based on their threshold for reordering. 

**Barcode Scanning in Products:** Within the product list or add/edit form, we will integrate the camera scanner. For example, when adding a new product, next to the Barcode field there’ll be a small scan icon – tapping it opens the camera to scan a code and auto-fill the result into the Barcode field. This avoids typing long codes. Similarly, in the product list, a floating “Scan” button could trigger a scan to find a product: the app scans an item’s barcode in the store and then shows that item’s detail (or highlights it). This is useful for price checks or quick edits. 

All product data is stored locally in SQLite table `articles`. Schema example: `articles(id, name, barcode, imageURI, purchasePrice, sellingPrice, unit, minQty, pmp, created_at, updated_at)`. If multi-store, current stock won’t be a single field here but rather managed in a separate `stock` table (store_id, article_id, quantity, ...). The product list can show either the total stock (sum across stores) or if we have a concept of a “primary store”, we might show that. We will clarify in Inventory module. 

The design of this module emphasizes ease of adding new items (possibly on the fly during a sale as well – e.g., cashier scans an unknown barcode, the system can prompt “Item not found, add it?”). The UI must be snappy, allow quick searching (so we’ll maintain an index or use a search algorithm on name/barcode). Even with hundreds of items, searching by name prefix or scanning by barcode should return results near-instantly given local DB access.

### Inventory & Store Management  
**Features:** This module covers how inventory is organized, especially if a business has **multiple stores or stock locations**. It includes: the ability to define multiple store locations, to track stock levels per store, to transfer stock between stores, and to perform inventory counts (stock audits). It also provides inventory valuation (total cost of stock on hand) which is useful for the business’s accounting. 

**Multiple Stores:** A tenant can have one or more stores/warehouses. For example, a wholesaler might have a main warehouse and two retail outlets. The system will allow the user to **create store entries** (each with a name, address, perhaps contact). Store could also include a default thermal printer configuration if each store has its own device, etc., but mainly it’s a label for stock segregation. 

When multiple stores exist, each product has a **stock quantity per store**. We will implement a table like `stock(store_id, article_id, quantity)`. Operations that change stock must specify the store. For example, a POS sale will reduce stock from the store where the sale is happening; a purchase will increase stock in the store that received the goods. If a user only has one store, the app may hide some of this complexity and just treat it as a single location. If multiple, we might need the user (especially Admin or manager) to **switch context** in the app to view a particular store’s data or see combined data. We can handle this by either a dropdown to select active store (for viewing stock, doing transactions) or allow selecting store on certain operations. Perhaps simpler: upon login or in settings, user chooses their default store (e.g. a cashier is assigned to one store and will only operate in that store’s context for sales). An Admin could switch store in an inventory view to see levels in each. We will ensure the UI clearly labels which store’s data is being shown. The Drawer menu could display the current store name, and a user could tap it to switch (like switching an account). 

**Stock Movements (Transfers/Adjustments):** This feature allows moving quantity from one store to another (if applicable) and adjusting inventory for reasons like damage, loss, or manual correction. We will provide a screen to “Transfer Stock”: the user picks an item, the source store, the target store, and quantity to transfer. The app will then decrement that quantity from source’s stock and increment in target’s stock (as a single logical transaction). This can be done offline (record in a local “movements” table) and synced later – the server will then update both stores’ records accordingly. For adjustments (e.g. throwing away expired products, or correcting a count discrepancy), the user can record a **Stock Adjustment** with a reason. For example, “-5 units of [Item] in Store A due to breakage.” The system will apply the change and keep a log of adjustments. We can have adjustment reasons like Damage, Theft, AccountingCorrection, etc., which the user can select. 

All stock movements and adjustments will be logged (who did it, when, what reason) so the owner can audit inventory changes. This log can be part of the Inventory module interface.

**Inventory Counts (Audits):** Periodically, businesses do a physical count of inventory. The app will assist with that via an **Inventory Count** feature. The user (perhaps Admin or Supporter role) can initiate a count for a store (either a **full count** of all items, or a **partial count** for a subset, e.g. a particular category or shelf). The app could generate a checklist of products to count (for full count, that’s all products; for partial, maybe the user scans items as they count). The user will enter the observed quantities. Once done, the app compares the counted numbers with the current system stock and generates **discrepancy reports**. The user can then approve adjustments to align the system with the actual count (and optionally note reasons for discrepancies). 

For simplicity in MVP, we might not have a full guided counting module (which can be complex) but rather allow the user to select an item and update its quantity to a new value after a count, marking the adjustment. Or we provide a way to import count results (maybe via CSV). However, a simple solution: a screen with a search or scan function – the user scans each item in the store and enters the counted qty; the app highlights difference from expected and offers to adjust. We’ll likely implement at least a basic version: **Partial count mode** where user can scan or select a product and input actual quantity, and the app records an adjustment (difference = actual - current) with reason "Inventory Count". For a **Full count**, the user would do this for all products; we might have an option to mark uncounted items as zero if they were missed (optional).

**Inventory Valuation:** At any time, the user might want to know “What is the total value of my stock on hand?” The app can calculate this as sum of (quantity * cost price) for all items (cost price we use could be the PMP or latest purchase price). We can show this per store and total. This metric could appear on the Dashboard or in an Inventory report. Since the data is local, the app can compute it quickly. For real-time display, we’ll update it whenever stock changes. 

**UI Example:** The Inventory module might have a screen showing all products with their stock per store. If multiple stores, it could be a tabular view: rows = products, columns = stores (with quantities). Or simpler, a dropdown to pick a store to view inventory. There will be buttons like “Transfer Stock” and “Inventory Count”. Tapping Transfer opens a form; tapping Inventory Count might open a specialized interface for counting (or navigates to partial count flow). We should also highlight low stock here as well (like filter to low stock items). 

**Technical:** We will maintain a `stores` table in SQLite (store_id, name, etc.), and a `stock` table. The `articles` table might not directly hold quantity if multi-store. Instead, when adding a new product, we’ll initialize a stock record for each store (or at least the main store). If the business has one store, we could also mirror that quantity in the articles table for simplicity, but likely better to always use the stock table for consistency. 

Stock transfers and adjustments will be recorded in a `stock_movements` table: fields could include an ID, article_id, from_store, to_store (nullable if adjustment), quantity_change (positive for incoming, negative for outgoing), reason, user_id, timestamp. This provides a clear history. When syncing to server, these become either updates to stock levels and an entry in a server-side log table for auditing.

Overall, this module ensures that multi-location businesses can effectively manage their inventory distribution, and that all inventory changes (sales, purchases, manual adjustments) are accounted for properly.

### POS System (B2C Sales)  
**Features:** The Point of Sale module is where daily sales to walk-in customers (B2C) are recorded. It is designed for speed and simplicity so that cashiers can handle transactions efficiently. Key features include: scanning or searching products to add to a sale, applying price adjustments or discounts, handling different payment modes (full payment or credit sale), printing receipts, and managing the sale cart (pause/resume, cancel, etc.). It also logs each sale for reports and updates inventory in real-time. Importantly, it supports offline operation – sales can be recorded offline and will sync to the backend later. 

**UI/UX:** The POS screen will be optimized for a **cashier’s workflow**:
- It will have a **product input area** at the top – either a search bar where the cashier can type product name or barcode, and/or a dedicated scan button. If a barcode scanner is connected, the cashier can simply scan an item’s barcode and it will appear in the input (because the scanner acts like keyboard input, it will trigger a search/add automatically). If using the camera, tapping the scan button will quickly pop up a scanner overlay, then add the item.
- A **list of items in the current cart** will occupy most of the screen. Each entry shows the product name, quantity, unit price, and total price. The cashier can tap an item to edit quantity or remove it. Possibly also allow price override per item (if bargaining is common in that context; see price negotiation below).
- A **summary section** at the bottom shows the subtotal, any discount or credit applied, and the total amount to pay. The cashier can then choose the payment mode.
- **Payment options**: Buttons or tabs for “Cash”, “Credit (Pay Later)”, and maybe “Other” (for check, card, mobile payment). Selecting Cash means the sale is paid in full now. Selecting Credit means the sale will be marked as customer owes money. In that case, the cashier should select a **Customer** who will be responsible for the credit (there could be a default “Walk-in” customer for general use, but typically if it’s a credit sale, they’ll have the person’s name recorded). The UI can prompt “Choose customer for credit” if Pay Later is chosen. The user can pick from existing customers or quickly add a new customer (just name/phone).
- A **complete/submit button** finalizes the sale. If a printer is connected and auto-print is enabled, it will then print the receipt. If no printer or printing is manual, the cashier can tap a “Print Receipt” button.
- There may also be an option to **park/pause the sale** – meaning save the current cart without completing, to resume it later. This is useful if the customer steps away or there’s some interruption. In UI, this could be a “Pause” button that clears the screen for a new sale, but stores the current cart in a “Pending Sales” list accessible somewhere (maybe an icon or menu in the POS screen to retrieve paused sales). Each paused sale might be labeled by a temporary ID or the first item’s name+timestamp for identification. The cashier can later select it to continue checkout.

**Price Negotiation & Discounts:** It’s mentioned there should be **shortcuts for price negotiations (e.g., F1 + P)**. On a touchscreen device, we won’t have function keys, but we can simulate this with an on-screen function: for example, tapping an item in the cart could allow editing its unit price or applying a percentage discount. Alternatively, we provide a global “Apply Discount” option for the whole sale (like a percentage or amount off the total). However, since negotiating per item price is common in wholesale/retail markets, we will allow **line item price override**. The cashier can long-press an item to edit its price for this sale only. This overridden price should be clearly marked (maybe highlight the item). The original price remains unchanged in the product database – this is just a special case. We might log that the price was overridden in the sale record for transparency. 

For keyboard shortcuts: if some setups involve a physical keyboard (some shops use tablets with keyboard or a PC running the app via emulator/PWA), we could support keys: e.g., pressing F1 then P could trigger a “price edit” mode. It’s an advanced feature; we’ll focus on making the touchscreen workflow smooth first, then include keyboard event handling for function keys as a progressive enhancement. 

**Printing Receipts:** After completing a sale, the app will generate a **receipt**. On a thermal printer, this will include the business name/logo, date/time, list of items (name, qty, price, total), the grand total, amount paid, change (if cash given, although we might not track cash tendered in MVP, but we could add a field to enter amount given and calc change), and if credit, it will say “Credit Sale - Customer: X owes Y DHS”. It will also include a footer message (configurable in settings, e.g. “Thank you for your purchase!”). We will have pre-defined receipt template possibly using the ESC/POS commands (text formatting, maybe a QR code of the sale ID or business contact). The app will send this to the printer via the integrated module. If the printer is not available, the app could offer to share a PDF receipt via WhatsApp or email as a fallback. 

**Sale Recording:** Each sale will be saved in the local database (table `sales` and `sale_items`). For example, `sales(id, date, total, paid_amount, payment_mode, customer_id, user_id, status)` and `sale_items(sale_id, article_id, quantity, unit_price, total_price, maybe discount)`. If payment_mode is credit, `paid_amount` might be 0 or partial and status could be “Pending” until payment is received. For full payments, paid_amount = total and status = “Paid”. We’ll also store `user_id` (cashier who made the sale) and maybe a sequential invoice number (unique per tenant, can be used on receipts). 

Inventory impact: upon sale completion, the app will **deduct the sold quantities from inventory** (in the appropriate store’s stock). This is done locally so that the stock displayed in the app is immediately updated. The sale record is marked to sync to server. When online sync runs, it will POST the sale and related items to the server. The server, in turn, writes them to the DB and returns any confirmation. If multiple devices can sell concurrently, server will aggregate sales and adjust central stock accordingly – on next sync, other devices might get stock updates.

**Offline considerations:** Selling offline is core – cashiers can continue to ring up sales even if connection drops. They won’t be able to charge cards (which is out of scope anyway), but cash and ledger sales are fine. We will just queue the sale for sync. If a sale fails to sync (server conflict or error), the app should keep it and retry, while possibly warning the admin. But conflicts are unlikely since it’s just adding records and decrementing stock.

**Session Management:** We might include the concept of a **register shift** – opening and closing a cashier session with a starting cash float and balancing at day’s end. This wasn’t explicitly requested, and given VSB context, might not be necessary for MVP. However, we could log when a cashier starts using the POS (first sale of day) and when they close (maybe a manual “Close register” action that could produce a small Z-report of totals). This can be an advanced add-on if needed.

### Customer & Credit Management  
**Features:** This module handles **customer accounts** and tracking of **credit (accounts receivable)**. In many small shops, there are loyal customers or other businesses that buy on credit and pay later (often informally tracked in notebooks). iGoodar Stock will formalize this by letting the user record customers and any outstanding payments. Features include: creating customer profiles, viewing purchase history and total owed, recording payments received against credit, and analyzing sales by customer. 

**Customer Records:** Each customer can have basic info: Name (or Business Name), Contact (phone number, maybe email), and perhaps an address. We may also include a “Customer type” or notes field. For individuals, name and phone suffice; for client businesses, we might store a company name and contact person. The system will generate a unique ID for each customer. 

The **Customer list** screen will show all customers (sortable by name or by outstanding balance). It can highlight those who owe money in a different color. The user can tap a customer to see details.

**Customer Detail & Credit:** On a customer’s detail view, show summary info: total purchase volume, total paid, current outstanding balance. Also list recent transactions (sales) for that customer – especially any that are unpaid (credit sales). For example: “Invoice 1003 on Jan 5: 500 DHS, Paid: 200, Outstanding: 300”. The Admin can then record a **payment** for that invoice or overall. When the customer comes to pay, the user can either mark specific invoices as paid (maybe the customer clears a particular bill), or just record a lump sum that will be applied to their balance. Simplicity suggests: select customer -> “Record Payment” -> enter amount and date, choose payment mode (cash, check, etc.), and optionally allocate to one or more invoices or just general. The system will reduce the outstanding accordingly and update those sale records to note payment.

We’ll maintain a `customers` table and a `payments` table. The sales already link to customers if credit. A payment might link to one sale or multiple; if multiple, we might just allow partial payments per sale (e.g. a sale has amount, paid_amount fields which can be updated, or we do a separate payment entity linking to sale ids). For MVP, a simpler way: each credit sale remains open until fully paid; a payment can reference a particular sale. If a payment is meant for multiple sales, the user can record separate entries for each sale or we implement a mini allocation UI. Possibly easier: when recording payment, list all open invoices with amounts; the user checks which ones are covered by this payment and how much. But that can be complex; might leave detailed allocation for future and now handle one payment per invoice at a time.

**Turnover per Customer:** In Reports or on the customer detail, we’ll show how much revenue each customer has generated (this can identify top customers). This can be computed from all sales associated with that customer (both cash and credit sales, since even cash sales could be associated with a known customer, though often only credit ones get a name). We will encourage the business to attach a customer to even cash sales if they want tracking (like loyalty tracking), but it’s not mandatory. So many sales may be “walk-in” without a customer, which is fine.

**Customer Categories:** Not explicitly required, but sometimes businesses categorize customers (retail vs wholesale clients, etc.). We won’t add complexity here now.

**UI/UX:** The Customers module would be accessible via the menu. A list view (possibly with a badge of amount owed). An “Add Customer” form for new entries – just name and phone (phone could be used as unique key or for contacting them, and possibly for future features like sending them a reminder SMS). On the customer detail page, provide actions like “New Sale” (to directly start a POS sale for that customer) and “Record Payment” if they have balance. 

We will incorporate language support (some customers might have Arabic names, which should display correctly when the app is in Arabic, etc.). Sorting should not break with different scripts.

When a **credit sale** is made in POS, and the cashier selects a customer, that sale is tied to the customer’s account. The customer’s balance increases by that amount. When a payment is recorded, the balance decreases. We will ensure these calculations update immediately locally so the cashier can see current balance if needed (for example, if a customer is buying more on credit, the cashier might want to know “they already owe X DHS”).

**Outstanding payments & notifications:** The app could send a reminder or show a notification when a credit sale is overdue (if we tracked due dates). We haven’t specified due dates, but perhaps by default consider credit due on next visit or allow adding a due date field per sale. If implemented, a notification could pop up “Customer X has an overdue payment of Y DHS”. This might be advanced; for MVP, we just track amounts and it’s on the owner to check.

**Reports:** We will include in the **Reports module** a “Accounts Receivable” report listing each customer and how much they owe, plus an aging if needed (like how long it’s been due). This helps the business follow up on debts. Also a “Customer Statement” could be generated and printed for a customer, listing all their purchases and payments – useful to hand to them as a bill. That could be done via PDF print of that detail view.

### Suppliers & Purchases  
**Features:** Manage **suppliers** (businesses or wholesalers that the VSB buys from) and record **purchase transactions**. This mirrors the customer/credit module but for payables. Key capabilities: create supplier profiles, log purchases (incoming stock) from suppliers, track payments owed to suppliers (credit from the business’s side), and update inventory when new stock arrives.

**Supplier Records:** Similar to customers, each supplier has a Name (company name or person’s name), contact info (phone, email), and maybe address. Could also store the usual payment terms or notes. Suppliers are listed in a Supplier directory accessible via menu.

**Purchases (Incoming Stock):** When the business buys products (restocks) from a supplier, the user will record a **Purchase Order/Invoice** in the app. This involves selecting the supplier, the date, and adding line items of products and quantities received, along with the purchase price for each (the cost). If the supplier gave an invoice number, that can be recorded too for reference. The total amount is calculated, and the user can mark how it was paid: fully paid (Cash/Check/etc.) or on credit (to be paid later). If on credit, it increases the amount owed to that supplier.

Recording a purchase has **two major effects**: 
1. It **updates inventory levels** for the products. Each item’s stock in the selected store increases by the quantity received. (E.g., if you bought 50 units of Product A for Store “Warehouse”, then Product A’s stock count for Warehouse is incremented by 50.) The app will do this update locally so inventory remains accurate offline.
2. It optionally updates the **cost information** for the product. Specifically, it can recalculate the PMP (average cost) if we use that. Also if the user had left the purchase price field blank initially, it can fill it with this actual cost. In any case, the record of this purchase retains the historical cost which can be used in profit calculations.

**Credit Tracking for Purchases:** If a purchase is not fully paid, it constitutes a **supplier credit (accounts payable)**. For instance, the business might get goods now and pay the supplier next month. The app should track how much is owed to each supplier. This is analogous to customer credit but in reverse. We will maintain a `supplier_id` on purchase records and a flag/amount for due. The user can later record a **Payment to Supplier** in the app when they pay off an invoice (or multiple). This reduces the outstanding balance.

**UI/UX:** There will be a **Suppliers list** and detail screens similar to customers. In a supplier’s detail, show total purchased and total owed. To record a new purchase, the user likely goes to a **New Purchase** screen (accessible from Supplier detail “New Purchase” or from a global “Add Purchase” button in the Purchases section). This screen functions like a reverse-POS: the user selects items and quantities that *came in*. We could reuse a similar interface (a list of items to add, perhaps even enable scanning the items as they unpack to add to the purchase list, which would be cool). However, scanning might be less needed here, because typically they have an invoice from supplier or a delivery note they can refer to. But we can allow it – e.g. scan each incoming product’s barcode to add it to the receipt, entering the quantity delivered and cost price from the invoice. 

Once items are listed, it shows a total cost. The user selects payment status: *Paid* (and method) or *Pay Later*. If paid, it doesn’t add to payables; if later, it records a liability.

After saving, the app should ideally allow printing a goods received note or at least confirm the addition. Inventory levels reflect the new stock. If the business tracks batch or expiration, we could add that, but not in MVP scope.

**Data storage:** A table `purchases` for purchase orders (with supplier_id, date, total, paid, etc.), and `purchase_items` for line items (each with article_id, quantity, unit_cost, total). The structure parallels the sales tables. We will also update the `stock` table for quantities and possibly store cumulative supplier purchase info in the product (like last cost, PMP).

**Supplier Payments:** Similar to customer payments, we might have a table for payments to suppliers. Or we can update the purchase record with payment info (like amount paid, payment dates). A simple approach: if one purchase is paid in multiple installments, multiple payment records are needed. So better to have a separate `supplier_payments` table linking to supplier and maybe a specific purchase id (or multiple). For MVP, perhaps assume payment is done per invoice – so they either pay it all at once or if partial, we update the purchase’s “paid_amount” and keep it open until settled. 

**Reporting:** In Reports, we will have accounts payable listing all unpaid purchase amounts. Also profit calculation will consider purchases to compute cost of goods sold (we might do a rough approach where every sale uses the current PMP as cost, or a FIFO using purchase records – but that’s complexity likely beyond MVP; average cost approach is fine).

**Offline usage:** Recording purchases can also be done offline (e.g. the owner receives stock in a warehouse with no internet, they input it, and it syncs later). It will sync to server to update central stock and financial records. No real conflict issues unless two devices receive stock for the same item concurrently, which is rare or just additive.

### Merchant Orders (B2B Orders)  
**Features:** This module enables **B2B ordering** where a “Merchant” user (e.g. a client retailer) can place orders for products from the wholesaler using the app. It can also be used by internal sales reps to record orders on behalf of merchants while offline (for example, traveling to client sites). The key features: allow creating an order (select items and quantities) offline, queue it if needed, notify the supplier/admin, and track the delivery status of that order through to completion.

**Order Placement:** A user with the **Merchant role** (or an internal user acting as a merchant) will have a simplified interface to **create an order**. This is similar to a POS sale but in reverse: the merchant picks what they want to buy *from* the business. They select multiple products and quantities (and possibly see the price the wholesaler charges – likely the Selling Price field is actually the wholesale price in that context). They submit the order. If they are offline (imagine a sales rep in a remote area taking an order on behalf of a store, or the merchant is offline), the order is saved locally and will sync when possible. If online, it goes directly to the server and triggers notifications.

**Order Notification:** When an order is received by the system (either instantly if online, or eventually via sync), the **Admin of the business is notified**. This could be an in-app notification or push notification: “New B2B Order #123 from Customer X”. In the app, the Admin or authorized staff can view the order details (items requested, quantities, the date/time). 

**Order Processing & Delivery:** The order will have a status. Initially “Pending” (submitted). The Admin can then mark it as “Accepted” or directly “In Delivery”. If there’s a process to prepare the order (pick items from warehouse), the status could be updated accordingly. Finally, when the goods are delivered to the merchant, the Admin or the delivery person can mark the order “Delivered” (and possibly capture a confirmation signature or photo in future). Once delivered, the inventory should be decremented from the supplying store. Actually, from the business’s perspective, fulfilling a B2B order is similar to a sale – it reduces stock. We have to decide if we also create a corresponding sale record for the wholesaler’s accounting. Possibly, yes: once delivered, that B2B order can convert to a Sale record (maybe with a special flag indicating B2B). It could also be on credit or paid, etc. So ideally, the Merchant order, once delivered, flows into either the POS records or a separate sales category.

**Payment for Orders:** Not explicitly outlined, but likely these orders might also be on credit or immediate payment. Since the wholesaler may allow the retailer to pay on delivery, etc. We could incorporate a payment status to the order (like Payment: Paid, COD, or Net 30, etc.). But to keep scope reasonable, we might treat it as follows: the order is just an order until delivered. Once delivered, the wholesaler will generate an invoice (which could be done through the app – printing an A4 invoice or a receipt) and mark whether it was paid. For consistency, we might integrate this with the existing sales/credit system: when delivered, if unpaid, it becomes a credit sale under that merchant’s customer account.

**Merchant User Experience:** If the merchant themselves is using the app, they would log in (but their view is restricted). They see an **Order screen** where they can browse the product catalog (likely with images and prices set by the wholesaler), add items to an order cart (similar to how one would shop on an e-commerce app), and submit it. They can view their past orders and their statuses (to know if it’s on the way or delivered). They might also see their outstanding balance if any. The UI should be straightforward: maybe categories of products or a search, add to cart, then confirm order.

**Sales Rep Experience:** If the wholesaler uses internal staff to take orders, the rep could either use a Merchant login for each client (less ideal) or use their own account with permission to place orders on behalf of clients. Another approach: the Sales Rep uses the POS interface but in a special mode where they create an order to be delivered (like a pending sale tagged for a client). However, given “Merchant user” is specified, we assume external clients are expected to use it as well. In any case, offline functionality is important – a rep could be out of service area, they should still be able to record the order and sync later.

**Backend & Data:** We will have an `orders` table (for B2B orders) separate from the retail sales. Fields: order_id, created_by (user/merchant id), customer_id (if merchants are also in customers table – we might treat merchants as customers of type business), status, etc. And an `order_items` table for the products and quantities ordered. The backend will enforce that a Merchant role can only create orders for their own associated customer record (likely merchant users are 1-to-1 with a customer entry in the system representing their shop; the Admin would set that up). 

When an order is synced to server, the server can optionally generate an order number and if push notifications are set up, send one to the admin’s device. The admin can then use an admin app interface to update status. We will mirror these changes back to the merchant’s app on next sync so they know the status. 

**Notifications:** Aside from push, within the app, the admin might see a badge on the Orders menu for new pending orders. Local notifications can also be used: when the Admin device receives the synced new order data, it triggers a local notification sound/alert (since the data is now in local DB).

**Link to Inventory & Sales:** As discussed, fulfilling an order will reduce stock. Perhaps the simplest approach: when admin marks Delivered, the app (or backend) automatically creates a Sale record for that customer for the ordered items, with payment mode as appropriate. This way all sales (B2C and B2B) eventually reflect in the sales ledger. Alternatively, we keep B2B orders separate for reporting. However, to compute total sales and stock movements seamlessly, converting to a sale might be easier. We’ll have to ensure it doesn’t duplicate stock deduction (maybe mark the order as delivered and treat it as final, not keep it open separately).

**UI for Admin:** The Admin’s app will have an **Orders** screen listing all B2B orders (new first). Tapping one shows details and allows updating status (with perhaps a dropdown for status or specific action buttons like “Mark as Delivered”). If delivered, possibly prompt to input any differences (if they couldn’t supply something, they might adjust quantities or mark an item backordered – that’s advanced though). For MVP, assume they deliver exactly what was ordered.

This module extends the utility of iGoodar Stock from just tracking internal sales to enabling a wholesaler-retailer supply chain workflow, which can be a standout feature for wholesalers using the app.

### Settings & Configuration  
**Features:** A central place for various configurations and less-frequent actions. Key subsections of Settings include: **Business Profile, Printer Setup, Localization, App Preferences, and Data Management**.

- **Business Profile:** Shows and allows editing of the business’s information like name, phone number, address, and logo. This information is used across the app (e.g., displayed on the Drawer header, and printed on receipts/invoices). The user (Admin) can update their store name or contact if needed. We might also allow adding a logo image here, which could then print on receipts. The business profile can also include fields like tax identification number if needed on invoices.  
- **Store Management:** If multiple stores are used, the Settings can list stores allowing the admin to add/edit store locations. (Alternatively, “Stores” might be its own top-level module, but to avoid clutter we can tuck it in Settings for now.) Admin can add a new store (name & address) or edit existing. They can also assign which store is the default for their device or for a user (though that might be in user management).  
- **User Management:** (If not given its own section in the app menu) can be part of settings as “Manage Users” for Admins to do what was described in User Management module. This might include inviting users, etc., as discussed. If it’s a small enough UI, embedding in Settings is fine.  
- **Printer Settings:** This is important for configuring printing. It will allow the user to connect to a printer and set preferences. For ESC/POS printers (Bluetooth/USB), we can list paired Bluetooth devices and let the user select the printer. We might include a “Test Print” button to print a sample receipt. Also, preferences like “Auto-print receipt after each sale” (toggle on/off) and “Receipt footer message” can be set here. For PDF printing, perhaps options like default paper size or an option to include/exclude certain details. If using network printers or AirPrint, those are usually invoked via OS dialog, so not much config needed for that beyond what Expo provides.  
- **Localization:** Provide the **Language selection** here. A simple toggle or dropdown for Arabic vs French (and any other languages if added later). When the user switches, we use RN’s internationalization API to change the language and layout direction. If possible, apply without full restart (there are techniques as in the GeekyAnts article to re-render UI ([Implementing Right-to-Left (RTL) Support in Expo Without Restarting the App - GeekyAnts](https://geekyants.com/en-us/blog/implementing-right-to-left-rtl-support-in-expo-without-restarting-the-app#:~:text=Step%203,Your%20Project))). If not, we may require an app restart prompt for language change to fully apply. This section might also allow switching numeric formats if needed (Arabic locales use Arabic-Indic digits sometimes). However, since Moroccan Arabic speakers often are used to seeing Latin digits in business, we might keep digits as Western for simplicity.  
- **Currency and Formats:** Likely fixed to **Moroccan Dirham (MAD)**. We’ll use “DHS” or “Dh” as the symbol as seen in the Excel. We can mention the currency in the business settings just for display or if expansion beyond Morocco is considered. Date format could also follow locale (we’ll use DD/MM/YYYY in French, maybe Hijri date optional? Probably not needed, stick to Gregorian for invoices). Basic formatting choices could be in settings if needed.  
- **Data Management:** Options like **Import/Export** data. For instance, the Excel import for products might be initiated here (“Import Products from Excel”). Possibly also an **Export Data** feature – e.g., export entire inventory or sales to CSV for backup. We can include a “Backup to CSV” that generates files the user can save. If PWA is used, maybe not as relevant, but for mobile it's a good practice to allow data export for peace of mind. Also, admin might want to reset or clear data (dangerous, maybe omit).  
- **Notifications Preferences:** The user might toggle certain notifications (sound/vibrate on new order, etc.). Basic on/off for now (the OS permission will be asked anyway, but we can let them control within app too).  

**Implementation:** The Settings will be structured as a list of sections. For example, we’ll have a scrollable view with section headers like “Profile”, “Printing”, “Localization”, etc. Each may navigate to a detailed screen or open a modal with the specific settings. Many of these settings, when changed, need to update local storage (for immediate effect and offline persistence) and sync to server (especially Business Profile changes, so that any other device for the same tenant gets updated info). We will store key settings in SQLite/MMKV as needed. The business info, for example, is stored in the tenant schema on server; the app will fetch it on login and store locally. When updated on one device, it syncs so another device sees it after sync.

**Print Config:** For Bluetooth, we might use a library call to list bonded devices (on Android). We will likely need to eject to bare or use a config plugin to use `react-native-bluetooth-escpos-printer` which presumably has a method to search for devices. We’ll put the selected device’s MAC address in MMKV so the POS module knows where to send print data. For iOS, pairing might be trickier (iOS might require MFi or use AirPrint; possibly limit direct BT printing to Android only in MVP if needed, and use AirPrint for iOS via expo-print).

**Security:** Some settings (like user management) should only show for Admin. We’ll hide those for other roles. 

**Installation/Updates:** We might list app version and perhaps provide a “Check for updates” if using OTA updates from Expo. That could be a small part of settings (not core though).

### Dashboard & Reports  
**Features:** A **Dashboard** provides at-a-glance metrics for the business, and the **Reports** section offers detailed data exports and visualizations of key performance indicators over time. This module is largely read-only analytics, drawing from the data collected by the other modules. 

**Dashboard Metrics:** On the main dashboard screen (which could even be the home screen when the app opens for admin users), we will display tiles or cards with metrics such as:
- **Total Stock Value:** The sum value of all inventory on hand (Quantity * cost for each item, summed). This gives an idea of how much money is tied in stock. It updates when purchases or sales happen.  
- **Today’s Sales Turnover:** Total sales amount made today (or in the last 24 hours). Possibly also yesterday vs today comparison. If offline, it calculates from local sales records; upon syncing, it can adjust if multiple devices contributed.  
- **Top 5 Selling Products:** A ranked list of the best-selling items (by quantity sold in a given period, say this month). This helps identify fast-moving stock. Could also be by revenue.  
- **Most Profitable Products:** Top items by profit (where profit = (selling price – cost) * quantity sold). This highlights items that contribute most to margin.  
- **Net Profit:** The profit (revenue minus cost of goods sold) over a period, e.g. month-to-date. This requires summing all sales revenue and subtracting the cost of those sold items. Using PMP as cost basis should be sufficient for an estimate ([Mobile DPAS - Offline Apps - DPAS Support](https://dpassupport.golearnportal.org/index.php/support/software-hardware/mobile-dpas-offline-apps#:~:text=Go%20offline%20with%20this%20simple,without%20reliance%20on%20network%2Finternet%20connectivity)).  
- **Top Customers:** For those who do B2B or have regular customers, list the customers with the highest purchase volumes (in value) in the last month or year. This can be based on the customer field in sales.  

These metrics can be presented as cards or a simple grid. Possibly include small charts (like a bar chart for top 5 products, or a line chart for sales trend). However, adding charts in a lightweight app might require a library; we can use a simple SVG or even ASCII-like bars in text. For MVP, numeric displays are fine, with maybe sparkline charts. 

The Dashboard should be **quickly readable**. For example: 
- “Stock Value: 125,000 DHS”  
- “Today’s Sales: 5,200 DHS (10 sales)”  
- “This Month Profit: 8,000 DHS”  
- “Best Seller: Coca-Cola 330ml (500 units sold)”  

We will ensure the info displayed is relevant to the user’s role. Cashiers might not see profit or stock value (only Admin and maybe Supporter/Viewer see those). Cashier could see just today’s sales that they made, for instance, or nothing at all (maybe skip dashboard for cashier role, or show a very limited one).

**Reports:** In the Reports section (accessible via menu), the user can generate and view more detailed reports, likely in list or table format. Types of reports:
- **Sales Reports:** e.g. a report of all sales in a date range. The user can filter by day, week, or choose custom dates. The output lists each sale (date, items, total, payment mode, customer if any). This can be useful for accounting or reconciling cash. A daily sales summary report could sum totals per day.  
- **Product Sales Report:** Show how many of each product was sold in a period (like an extended version of top products, for all products). Useful for restocking decisions.  
- **Inventory Report:** A snapshot of current inventory levels per product (and per store if applicable), including total value. This can be exported or printed for an inventory check.  
- **Low Stock Report:** Essentially list of all items below min stock, which can be printed or saved – useful as a reorder list.  
- **Customer Balance Report:** List of all customers who owe money along with amounts (accounts receivable aging report).  
- **Supplier Balance Report:** Conversely, list of what the business owes to each supplier (accounts payable).  
- **Profit/Loss Report:** Over a period, total revenue, total cost of goods sold, and gross profit. Possibly also expenses if they input any (not in scope, unless we consider supplier payments as expenses for COGS).  

Each report can be viewed on screen in a simple table format (the app can generate a ScrollView table or even a webview for complex formatting, but probably not needed). More importantly, each should have an **Export option**: either **Export to PDF** or **Export to CSV**. 
- **PDF export:** We can create a nicely formatted PDF for the report, suitable for printing on A4. For example, a sales report PDF with a header (business name, report title, date range) and a table of entries. The Expo Print API can help convert an HTML or React Native view into a PDF. Alternatively, we could send a request to the server to generate a PDF (especially if heavy data), but since offline is a goal, we should handle as much as possible locally.  
- **CSV export:** This is straightforward. The app can compile the data in CSV format (commas or semicolons separated values) and then offer it via share (the user could send it to email or open it in Excel mobile app). Many business owners might appreciate CSV to do custom analysis or share with their accountant.

When exporting, if the device is online, we could also upload the file to the server or cloud for safekeeping or email, but an immediate share is fine.

Performance-wise, generating reports on device for moderate data is fine. For very large data (like years of sales), we might implement some limits or require filtering by date to avoid performance issues on low-end phones.

We should ensure **reports are accessible offline** for any data that’s been synced to the device. If some data is only on server (say older records purged from device), the report might be incomplete offline – we’ll document that, but for MVP assume all relevant data stays on device.

The UI for selecting report range can use date pickers (Expo has or we use a simple approach). The report output could be shown in a new screen with an export button.

### Notifications & Alerts  
**Features:** A system for alerting users about important events, either via **local notifications** (in-app or device notifications that work offline) or **push notifications** (from server when online). This module isn’t a screen per se (though we might have a Notification Center screen listing recent notifications), but rather background functionality integrated with other modules.

**Local Notifications:** These are triggered by the app itself without server involvement:
- **Low Stock Alerts:** As mentioned, when an item’s quantity falls below its minimum, the app schedules a local notification: e.g., “📉 Low stock: Item X is below minimum (only Y left)”. This check can happen whenever stock changes (after a sale or purchase) or maybe once a day scanning through inventory. Because it’s offline-first, this does not require server – the app’s local data suffices. The user (likely Admin role) will receive this notification on their device. If multiple users/devices for same tenant, each device would independently trigger based on their local data; slight duplication might happen if both admin and another user have the app open, but that’s okay. We can refine to maybe only notify admin or a specific role by configuration.  
- **New Order Alert (internal):** If the Admin’s device has been offline and then reconnects and pulls a new merchant order, we can trigger a local notification to catch their attention: “🛒 New B2B Order from Client X”. Similarly, if a customer payment is overdue (if we implement due dates and some logic), the app could locally remind “Customer Y owes Z DHS since [date].”  
- **Credit Limit Alerts:** If the business sets a credit limit for a customer (not explicitly asked, but could be a nice feature), and a new sale would exceed it, the app could warn the cashier. Without over-engineering, we can at least notify the admin if any customer’s debt exceeds a certain threshold (maybe a fixed value or configurable per customer). This would again be a local check after each credit sale or on a schedule.

We will use Expo’s Notifications API for scheduling local notifications. On Android, they’ll appear in the system tray; on iOS, in the notification center, even if app is closed (Expo can schedule local notifications to fire at a set time or immediately). 

**Push Notifications (Server-driven):** These are useful for when the app is not running or for cross-device communication:
- When a **Merchant places an order** and if the Admin is not actively using the app, the server can send a push notification to the Admin’s device: “New Order #123 from [Merchant Name]” so they know to open the app and check.
- If in future an admin wants to broadcast something to all users or a system message, push could be used, but main need is order alerts and maybe remote low-stock if business owner isn’t on site (though since their device has data, local covers it).
- Possibly, if a supplier also had a system or if we integrate something like sending a push to a merchant that their order is delivered or ready, etc., but likely outside scope.

**Implementation for Push:** We will integrate **Expo Push Notifications** (which uses Firebase FCM under the hood). Each device on login will register for push and get a token. The token is sent to our server and stored against that user. When an event occurs (e.g. an order placed), the server finds the target user(s) (the admin of that tenant) and sends a push via Expo’s push service. This requires internet connectivity on the device to receive, obviously. If the device is offline, they’ll get it when they come online if not expired, but since our app anyway will sync, the local data will alert them too. So push is a secondary channel for immediacy. We'll ensure to ask user permission for notifications on first run.

**In-App Notification Center:** We can also include within the app a screen or dropdown showing recent notifications (like a bell icon that lists "Stock A low, Order #123 arrived" etc.). This is convenient so if a user opens the app after many notifications, they see what happened. We can store notifications in SQLite (with a simple table of type, message, timestamp, read/unread). This is an extra, but useful for completeness.

**Sound/Vibration:** For local notifications, we can specify the notification to play a sound or vibrate especially for critical alerts. The user can adjust this in settings.

**Role-based notifications:** By default, Admin gets most alerts (low stock, new orders). Cashiers might get alerts related to their work (perhaps if a certain product they need is now back in stock or if an order they prepared is canceled – but those are niche). Merchant users might get a push when their order is accepted or on the way (if we implement that). We can implement push for merchant: server sends "Your order #123 has been dispatched" etc. 

**Edge cases:** If the user is actively using the app when an event occurs (e.g. they are on the Orders screen when a new order arrives via sync), we can show an in-app banner or simply update the list with a highlight. We should avoid double notifying (system notification and in-app at same time) for active sessions where possible.

### User Experience & Design Considerations  
**Mobile-First & Responsive Layout:** iGoodar Stock is designed primarily for **5–7 inch smartphone screens**, ensuring that all elements are easily visible and touchable on small devices. We use a single-column layout with vertical scrolling in most screens. Buttons and interactive controls are kept large enough (approximately  Forty-eight pixel touch targets) to avoid mis-taps. On larger devices (like 7-inch tablets), the UI can stretch, but we’ll generally stick to the mobile layout (perhaps showing more columns in lists if space permits). The drawer menu will cover most of the screen when open on a phone; on a tablet, it could be a partial sidebar. We’ll test across common resolutions to ensure the design scales well. 

**RTL Support:** The app fully supports **Right-to-Left (RTL)** for Arabic. This includes mirroring the layout and aligning text to the right. React Native’s `I18nManager` will be used to flip the app into RTL mode when Arabic is select ([Implementing Right-to-Left (RTL) Support in Expo Without Restarting the App - GeekyAnts](https://geekyants.com/en-us/blog/implementing-right-to-left-rtl-support-in-expo-without-restarting-the-app#:~:text=Step%203,Your%20Project))2】. We will ensure all custom components respect this (using `flexDirection: 'row-reverse'` when needed or dynamic styles). Icons that imply direction (like forward/back arrows) will also be swapped. The goal is that the Arabic UI feels native to Arabic readers, not a left-to-right design with Arabic text awkwardly placed. We’ll also use appropriate Arabic translations for all terms, and consider cultural nuances (e.g. using Arabic words that are common in Moroccan business context). 

**Clarity for Low Tech Literacy:** Since many users might not be tech-savvy, the UX must be **intuitive and forgiving**:
- We will use **simple language** for labels and messages (in translation, using common terms a shopkeeper would use, avoiding technical jargon). For instance, use “Add Product” instead of “Create Inventory Item”.
- Key actions will be visually highlighted (e.g. a big “+” floating button for adding new items or starting a new sale). 
- Where possible, use pictograms alongside text. E.g., a printer icon next to “Print Receipt” or a bell icon for notifications. This dual coding helps understanding.
- **Guided flow**: critical processes like completing a sale or adding a product will have a clear sequence (perhaps even a step-by-step for first-time users). We might include tooltips or a one-time tutorial screens, but even without, the flow is straightforward: e.g., in POS, scan or choose item, confirm quantity, take payment, done.
- **Error prevention & handling**: The app should prevent mistakes like forgetting to select a customer for a credit sale (we’ll prompt if “Pay later” is chosen without a customer). If the user tries to leave a screen with unsaved data (like half-filled product form), we confirm or auto-save as draft.
- We also allow undo for certain actions (like removing an item from cart or an inventory adjustment, maybe via a snackbar with “Undo”).
- No unnecessary confirmations for routine tasks (to keep speed), but confirm destructive actions (like deleting a product or canceling a sale).

**Performance and Feedback:** Ensure the app remains **snappy**:
- Show feedback for actions: e.g., after saving a sale, show a brief “Sale saved” message (toast) especially if offline (so user trusts it’s recorded). If printing, show “Printing…” indicator until done.
- For long operations like importing data or generating a report, show a progress spinner or percentage so user knows the app is working and not frozen.
- Keep animations minimal and fast; use React Native’s LayoutAnimation or lightweight libraries for smooth transitions without lag.
- The <20MB app size target will be met by trimming unnecessary libraries and assets. We avoid heavy dependencies (for example, we might avoid including a giant chart library and instead code simple charts or use the server to generate one if needed). We’ll also use image assets in appropriate resolution – no large images bundled that aren’t needed on mobile.

**Testing with Real Users:** We plan to test the design with a few local shop owners to ensure it meets their expectations. Their feedback (like which terms make sense, or which workflows are most common) can refine the UX. For example, if many users prefer using the app in French but input product names in Arabic (or vice versa), we should ensure the app handles mixing languages gracefully (UTF-8 support, etc., which is by default but we’ll verify).

**Accessibility:** While not explicitly requested, we will naturally incorporate some accessibility best practices:
- Sufficient color contrast between text and background (important if using brand colors – we’ll ensure, for instance, that any text on colored buttons is white or black appropriately for contrast).
- Font sizes can be scaled if the user’s device accessibility settings have larger text, our styling should not break (using relative units where possible).
- Descriptive labels for buttons/icons for screen readers (Aria labels or RN’s accessibilityLabel).
- The app mostly targets users without disabilities, but these steps ensure it’s not unusable for those who do.

**Overall,** the design brief ensures that iGoodar Stock will be a **user-friendly, efficient, and reliable** tool. By adhering to the branding, focusing on critical workflows (sales, purchases, inventory updates) and handling the unique challenges of offline usage and bilingual support, the application will greatly streamline daily operations for Moroccan small businesses.

## Deployment Strategy  
**Android (APK & Play Store):** For Android users, we will provide a direct **APK file** for side-loading (this is useful for areas where Play Store access is limited or for quick testing). The app will also be published on the **Google Play Store** under the iGoodar Stock name so that businesses can easily find and install it. We will use Expo’s build service (EAS Build) to generate the APK/AAB. The multi-tenant nature doesn’t affect the client app distribution – all tenants use the same app, and data separation is handled server-side. We’ll sign the app with the appropriate keystore and follow Play Store guidelines for listing (including French and Arabic descriptions on the store listing to reach the target audience). After publishing, updates can be delivered through the Play Store, but we can also integrate **Expo Updates (OTA)** for minor fixes; however, caution with OTA when native modules (like the printer library) are involved – we will test thoroughly to ensure compatibility.

**iOS (TestFlight & App Store Prep):** For iOS, since many small business owners in Morocco use Android, iOS might be secondary, but we’ll still support it for those who have iPhones or iPads. Initially, distribution will be via **TestFlight** (Apple’s beta testing platform). We’ll invite the client’s team or pilot users through TestFlight for internal testing. This requires an Apple Developer account and app registration. Eventually, we aim to list on the **Apple App Store**. We must ensure the app meets App Store guidelines (no private APIs, proper permission usage explanation in the info.plist for camera, bluetooth, etc.). The bilingual support and offline functionality should pose no issues for review. We will include French as the primary localization and Arabic as well in the App Store metadata. Note: for iOS, background sync might be limited (we may use `AppState` and perform sync when app comes to foreground rather than true background due to iOS restrictions, unless using BackgroundFetch which has limits). This is acceptable as users typically will open the app daily.

**Progressive Web App (Optional PWA):** An optional distribution is a **PWA** for web browsers. This could allow accessing iGoodar Stock from a computer or an unsupported device. Expo can build a web version since it’s React Native Web compatible (with some effort for compatibility of certain components). If we provide a PWA, users could go to a URL, log in and use an online version. **However, note that some features would be limited**: offline usage on PWA is possible via service workers and IndexedDB (we could potentially use an IndexedDB adapter for data storage), but printing to a thermal printer via web is problematic (no direct Bluetooth from web, though one could print to a network printer or generate PDF). Also, barcode scanning via camera works on web (getUserMedia), but HID scanner would just act as keyboard input which should work in a web input field as well. We might include PWA primarily for administrative tasks (like importing data on a desktop, or viewing reports on a big screen). Given our main focus is mobile, PWA is a nice-to-have. If time permits, we’ll configure the app for web with a responsive layout that possibly shows more columns in tables etc. The PWA can be offered via a URL like `app.igoodar.com` and can be installed on desktop or mobile home screen. It will use the same backend (just a different frontend build). We’ll ensure data sync logic detects the platform and uses appropriate storage (maybe falling back to localStorage/IndexedDB for web). This can broaden the usage scenarios (for example, the business owner might use the mobile app on the go, and check reports on his laptop via the web app). 

**Multi-Tenancy on Server Deployment:** The backend being multi-tenant means we will run a single server (or a cluster) for all businesses. We need to ensure it scales as number of tenants grows. We will probably containerize the backend (Docker), and use an instance of PostgreSQL with sufficient resources. Each new tenant (business) creation process should be automated – possibly a dedicated API or an admin panel on the server that we (the SaaS provider) use to approve/create new tenants (if sign-up is open, it can be automatic). The Postgres user that the API uses will need the rights to create schemas. We’ll implement a naming convention for schemas (like schema “tenant_<tenantId>”). For security, we might also ensure that queries are parameterized properly to prevent any SQL injection that could escape schema context.

**Data Synchronization & Backup:** Since data lives on devices and server, we’ll encourage users to go online daily or periodically so that the server has the latest data (for backup and multi-device sync). The server will do regular backups of the database so tenant data is safe. If a device is lost or replaced, as long as they synced recently, their data is safe on cloud. They can reinstall the app, log in, and the app will pull all data from server back to a fresh SQLite (initial sync might download all current products, customers, open invoices, etc.). We will implement this initial data seeding on login effectively – possibly paginating through large tables.

**Support & Updates:** We will set up monitoring for errors (perhaps using Sentry for React Native for runtime errors) to catch crashes or issues in the field. Given the target users, we’ll also provide support contacts. The **Supporter role** in the app can be used by our support team to log in (with permission) and inspect a tenant’s data if troubleshooting is needed – this is why that role exists. We’ll log sensitive actions and maybe have an audit log to help debug user issues (“why is stock of X wrong?” – check history etc.). 

On the development side, after initial launch, we expect to iterate with improvements. The design allows adding features like VAT/tax handling or printing barcode labels, etc., in future updates. 

By following this design brief, the development team (or coding assistant) should have a clear roadmap to implement iGoodar Stock. The structure and technologies chosen align well with the requirements: **mobile-first UX, robust offline functionality, and comprehensive inventory/POS features**. The result will be a powerful tool that operates reliably in low-connectivity environments and addresses the real pain points of VSB retailers and wholesalers. 

